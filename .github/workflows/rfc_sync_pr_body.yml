name: RFC Sync PR Body

on:
  pull_request:
    types: [opened, synchronize, ready_for_review, reopened]

permissions:
  pull-requests: write
  contents: read

jobs:
  sync:
    if: startsWith(github.event.pull_request.head.ref, 'rfc/')
    runs-on: ubuntu-latest
    steps:
      - name: Update PR body from rfc.md front-matter
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr = context.payload.pull_request;

            // Find RFC folder
            const files = await github.paginate(
              github.rest.pulls.listFiles,
              { owner, repo, pull_number: pr.number }
            );
            const sample = files
              .map(f => f.filename)
              .find(p => /^rfcs\/\d{4}-[^/]+\//.test(p));
            if (!sample) return;
            const folderRoot = sample.match(/^(rfcs\/\d{4}-[^/]+)\//)[1];
            const rfcPath = `${folderRoot}/rfc.md`;

            // Load rfc.md
            let text;
            try {
              const { data } = await github.rest.repos.getContent({
                owner, repo, path: rfcPath, ref: pr.head.sha
              });
              text = Buffer.from(data.content, 'base64').toString('utf8');
            } catch {
              return;
            }

            // Parse frontmatter
            const fm = (() => {
              const m = text.match(/^---\n([\s\S]*?)\n---/);
              if (!m) return {};
              const raw = m[1];
              const read = (key) => {
                const r = new RegExp(`^${key}:\\s*["']?([^\\n"']+)["']?\\s*$`, 'mi');
                const mm = raw.match(r); return mm ? mm[1].trim() : '';
              };
              const list = (key) => {
                const r = new RegExp(`^${key}:\\s*\\[([^\\]]*)\\]`, 'mi');
                const mm = raw.match(r);
                if (!mm) return '';
                return mm[1]
                  .split(',')
                  .map(s => s.trim())
                  .filter(Boolean)
                  .join('<br>');
              };
              const block = (key) => {
                const r = new RegExp(`${key}:\\s*\\|\\s*\\n([\\s\\S]*?)(\\n\\w+:|$)`, 'm');
                const mm = raw.match(r); return mm ? mm[1].trim() : '';
              };
              return {
                id: read('id'),
                title: read('title'),
                status: read('status'),
                authors: list('authors'),
                reviewers: list('reviewers'),
                created: read('created'),
                last_modified: read('last_modified'),
                tracking_issue: read('tracking_issue'),
                dependencies: list('dependencies'),
                supersedes: list('supersedes'),
                summary: block('summary'),
                motivation: block('motivation')
              };
            })();

            // Build a metadata table
            const table = [
              '| Field | Value |',
              '|-------|-------|',
              `| **ID** | ${fm.id || ''} |`,
              `| **Title** | ${fm.title || pr.title} |`,
              `| **Status** | ${fm.status || 'Draft'} |`,
              `| **Authors** | ${fm.authors || ''} |`,
              `| **Reviewers** | ${fm.reviewers || ''} |`,
              `| **Created** | ${fm.created || ''} |`,
              `| **Last Modified** | ${fm.last_modified || ''} |`,
              `| **Tracking Issue** | ${fm.tracking_issue || ''} |`,
              `| **Dependencies** | ${fm.dependencies || ''} |`,
              `| **Supersedes** | ${fm.supersedes || ''} |`
            ].join('\n');

            // Choose a status badge
            const status = fm.status || 'Draft';
            let badge = '';
            if (status.toLowerCase() === 'draft') {
              badge = '![Status: Draft](https://img.shields.io/badge/Status-Draft-yellow)';
            } else if (status.toLowerCase() === 'accepted') {
              badge = '![Status: Accepted](https://img.shields.io/badge/Status-Accepted-brightgreen)';
            } else if (status.toLowerCase() === 'rejected') {
              badge = '![Status: Rejected](https://img.shields.io/badge/Status-Rejected-red)';
            }

            // Build body
            const body = [
              `# RFC Metadata`,
              ``,
              `${badge}`,
              ``,
              table,
              ``,
              `# Summary`,
              fm.summary || "_(add summary in rfc.md)_",
              ``,
              `# Motivation`,
              fm.motivation || "_(add motivation in rfc.md)_",
              ``,
              `# Primary Document`,
              `[rfc.md](/${owner}/${repo}/blob/${pr.head.ref}/${rfcPath})`
            ].join('\n');

            await github.rest.pulls.update({
              owner, repo,
              pull_number: pr.number,
              body
            });
